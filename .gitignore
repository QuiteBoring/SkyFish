package chime.calculator.util;

import chime.calculator.config.PathConfig;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class Node {
    private final int x, y, z; // 3D coordinates
    private Node parent;
    private double gCost = Double.MAX_VALUE; // Cost from start to this node
    private double hCost = 0; // Heuristic cost to end

    public Node(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public Node(int[] coords) {
        this(coords[0], coords[1], coords[2]);
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent = parent;
    }

    public double getGCost() {
        return gCost;
    }

    public void setGCost(double gCost) {
        this.gCost = gCost;
    }

    public double getHCost() {
        return hCost;
    }

    public void setHCost(double hCost) {
        this.hCost = hCost;
    }

    public double getTotalCost() {
        return gCost + hCost;
    }

    public void calculateCosts(Node endNode) {
        this.hCost = calculateHeuristic(endNode);
    }

    public double calculateHeuristic(Node endNode) {
        // Euclidean distance for flying entities
        return Math.sqrt(
            Math.pow(endNode.x - this.x, 2) +
            Math.pow(endNode.y - this.y, 2) +
            Math.pow(endNode.z - this.z, 2)
        );
    }

    public double distanceTo(Node neighbor) {
        // Distance between this node and a neighbor
        return Math.sqrt(
            Math.pow(neighbor.x - this.x, 2) +
            Math.pow(neighbor.y - this.y, 2) +
            Math.pow(neighbor.z - this.z, 2)
        );
    }

    public List<Node> getNeighbors(PathConfig config, Node endNode, boolean isFlying) {
        List<Node> neighbors = new ArrayList<>();

        // Add possible movement directions (6 for cardinal directions, 26 for full 3D diagonal movement)
        int[][] directions = {
            {1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1},
            {1, 1, 0}, {1, -1, 0}, {-1, 1, 0}, {-1, -1, 0},
            {1, 0, 1}, {1, 0, -1}, {-1, 0, 1}, {-1, 0, -1},
            {0, 1, 1}, {0, 1, -1}, {0, -1, 1}, {0, -1, -1},
            {1, 1, 1}, {1, 1, -1}, {1, -1, 1}, {1, -1, -1},
            {-1, 1, 1}, {-1, 1, -1}, {-1, -1, 1}, {-1, -1, -1}
        };

        for (int[] dir : directions) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            int nz = z + dir[2];

            if (isValid(nx, ny, nz, config, isFlying)) {
                neighbors.add(new Node(nx, ny, nz));
            }
        }

        return neighbors;
    }

    private boolean isValid(int nx, int ny, int nz, PathConfig config, boolean isFlying) {
        // Validate boundaries
        if (nx < 0 || ny < 0 || nz < 0 || nx >= config.grid.length || ny >= config.grid[0].length || nz >= config.grid[0][0].length) {
            return false;
        }

        // Check if the node can be traversed
        if (isFlying) {
            // Flying ignores most obstacles, but optionally check for airspace limits
            return config.grid[nx][ny][nz] != config.BLOCKED;
        } else {
            // Walking rules
            return config.grid[nx][ny][nz] == config.WALKABLE;
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Node node = (Node) o;
        return x == node.x && y == node.y && z == node.z;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y, z);
    }
}


package chime.calculator;

import chime.calculator.config.PathConfig;
import chime.calculator.util.Node;
import chime.util.LogUtil;
import chime.util.Timer;

import java.util.*;

public class PathFinder {

    private static final Timer timer = new Timer();

    public static List<Node> findPath(PathConfig config) {
        PriorityQueue<Node> open = new PriorityQueue<>(Comparator.comparingDouble(Node::getTotalCost));
        Set<Node> closed = new HashSet<>();

        Node startNode = new Node(config.start);
        Node endNode = new Node(config.end);

        startNode.calculateCosts(endNode);

        open.add(startNode);
        timer.reset();

        while (!open.isEmpty()) {
            if (timer.hasElapsed(config.timeout, false)) {
                LogUtil.sendError("Pathfinding has timed out.");
                break;
            }

            Node current = open.poll();

            if (current.equals(endNode)) {
                return reconstructPath(current);
            }

            closed.add(current);

            for (Node neighbor : current.getNeighbors(config, endNode, true)) { // "true" for flying mode
                if (closed.contains(neighbor)) {
                    continue;
                }

                double tentativeGCost = current.getGCost() + current.distanceTo(neighbor);

                if (tentativeGCost < neighbor.getGCost()) {
                    neighbor.setParent(current);
                    neighbor.setGCost(tentativeGCost);
                    neighbor.setHCost(neighbor.calculateHeuristic(endNode));

                    if (!open.contains(neighbor)) {
                        open.add(neighbor);
                    }
                }
            }
        }

        LogUtil.sendError("Pathfinding failed to find a valid path.");
        return Collections.emptyList();
    }

    private static List<Node> reconstructPath(Node current) {
        List<Node> path = new ArrayList<>();
        while (current != null) {
            path.add(current);
            current = current.getParent();
        }
        Collections.reverse(path);
        return path;
    }
}
